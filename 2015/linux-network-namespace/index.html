<!DOCTYPE html><html><head><title>Network namespace挺有趣 | Carlog</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><link rel="alternate" href="atom.xml" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/main.css" type="text/css"></head><body><header><div class="wrapper"><a href="/" class="site-title"><code>Carlog</code></a><div class="menu"><span class="hamburger"><span></span></span></div><nav role="navigation" class="nav"><a href="/">Home</a><a href="/archives">Archives</a><a href="/atom.xml">RSS</a></nav></div></header><section class="main post"><div class="wrapper clearfix"><div class="post-header"><h2 class="post-title"><a href="/2015/linux-network-namespace/">Network namespace挺有趣</a></h2><time datetime="2015-11-03T13:57:14.000Z">November 3, 2015</time></div><div class="post-content"><p>今天才发现<code>ip netns</code>是这么强大。<code>ip netns</code>操作的就是Linux network namespace。</p>
<p>namespaces, cgroups这些技术是Linux LXC的基础，所以也是现在流行的Docker的基础。对于namespeces，有process的namespace，也有network的namespace。如果一个进程跑在一个process namespace中，那么它只能看到同在这个namespace中的进程，也只能和这些进程通信。你在这个namespace中<code>ps -elf</code>一下，你也只能看到跑在这个namespace的进程。</p>
<a id="more"></a>
<p>Linux的network namespace也是一样的道理，只是它是用于隔离网络。每个network namespace中有独立的网络设备，有自己独立的<code>lo</code>。每个network namespace中也有自己独立的路由表，iptables规则等。结合veth，利用network namespace可以很方便的在主机配置虚拟网络。具体什么是network namespace可以<a href="http://man7.org/linux/man-pages/man8/ip-netns.8.html" target="_blank" rel="external">man 8 ip-netns</a>看看。</p>
<h2 id="A-simple-example"><a href="#A-simple-example" class="headerlink" title="A simple example"></a>A simple example</h2><p>为了方便,我们不使用Linux bridge或者OVS，只在主机中配置一个点到点的简单网络。</p>
<p>首先创建2个namespace</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><div class="line"><span class="built_in">ip</span> netns <span class="keyword">add</span> ns1</div><div class="line"><span class="built_in">ip</span> netns <span class="keyword">add</span> ns2</div></pre></td></tr></table></figure>
<p>此时<code>ls /var/run/netns</code>会看到2个文件<code>ns1</code>和<code>ns2</code>。这2个文件打开后产生的fd指向对应的namespace。</p>
<p>创建veth <strong>pair</strong></p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><div class="line">ip link add <span class="keyword">name</span> tap1 <span class="keyword">type</span> veth peer <span class="keyword">name</span> tap2</div></pre></td></tr></table></figure>
<p>这时，在主机上就会多出2个interface tap1和tap2。然后把这2个interface分别加到ns1和ns2中</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><div class="line">ip <span class="keyword">link</span> <span class="built_in">set</span> tap1 netns ns1</div><div class="line">ip <span class="keyword">link</span> <span class="built_in">set</span> tap2 netns ns2</div></pre></td></tr></table></figure>
<p>这时，主机上原来多出的2个interface又会消失。此后，如果我们要操作这些interface的话，必须要加上<code>ip netns exec &lt;ns-id&gt;</code>前缀，比如现在把这2个interface配上地址并起起来。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><div class="line"><span class="built_in">ip</span> netns exec ns1 <span class="built_in">ip</span> addr <span class="keyword">add</span> <span class="number">2.2</span><span class="meta">.2</span><span class="meta">.1</span>/<span class="number">24</span> dev tap1</div><div class="line"><span class="built_in">ip</span> netns exec ns1 <span class="built_in">ip</span> link set tap1 <span class="meta">up</span></div><div class="line"></div><div class="line"><span class="built_in">ip</span> netns exec ns2 <span class="built_in">ip</span> addr <span class="keyword">add</span> <span class="number">2.2</span><span class="meta">.2</span><span class="meta">.2</span>/<span class="number">24</span> dev tap2</div><div class="line"><span class="built_in">ip</span> netns exec ns2 <span class="built_in">ip</span> link set tap2 <span class="meta">up</span></div></pre></td></tr></table></figure>
<p>这个时候，你就可以尝试 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">ip</span> <span class="selector-tag">netns</span> <span class="selector-tag">exec</span> <span class="selector-tag">ns1</span> <span class="selector-tag">ping</span> 2<span class="selector-class">.2</span><span class="selector-class">.2</span><span class="selector-class">.2</span></div></pre></td></tr></table></figure>
<p>没有意外的，应该是可以ping通的。你也可以在ns2的对应interface上抓包</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">ip netns exec ns2 tcpdump -<span class="selector-tag">i</span> tap2</div></pre></td></tr></table></figure>
<p>如果你觉得输入前面的<code>ip netns exec &lt;ns-id&gt;</code>很麻烦，你也可以在这个namespace中运行xterm。当然这需要你通过GUI登录机器，或者进行x-window转发。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">ip netns <span class="built_in">exec</span> ns1 xterm &amp;</div></pre></td></tr></table></figure>
<p>上面的命令会打开一个新的terminal。<code>ip link list</code>一下，你应该就能看到<code>lo</code>和<code>tap1</code>了。</p>
<h2 id="How-pipework-works-with-Docker-containter"><a href="#How-pipework-works-with-Docker-containter" class="headerlink" title="How pipework works with Docker containter"></a>How pipework works with Docker containter</h2><p>如果你尝试过让Docker container和外部通信，你可能用过<a href="https://github.com/jpetazzo/pipework" target="_blank" rel="external">jpetazzo/pipework</a>。pipework是一个简单的用来给LXC container配置网络的Bash脚本。</p>
<p>pipework使用起来通常是这样(当然还有很多其他用法)：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><div class="line">pipework br0 <span class="number">904</span>bcf846a3e <span class="number">10.10</span><span class="number">.10</span><span class="number">.9</span>/<span class="number">24</span></div></pre></td></tr></table></figure>
<p>其中<code>br0</code>是bridge名，<code>904bcf846a3e</code>是container id，<code>10.10.10.9/24</code>会配到这个container中新创建的interface eth0上。然后你把主机上的物理interface加到这个<code>br0</code>中，这个container就可以和外部网络通信了。pipework用的其实就是上面例子中的那些工具。</p>
<p>pipework首先会根据第一参数，在此是<code>br0</code>，去检查主机上有没有这个bridge，如果有的话，会判断是Linux bridge还是OVS bridge。如果主机上不存在，pipework会创建这个bridge，pipework也会根据这个参数去猜测用户是想创建Linux bridge还是OVS bridge。</p>
<p>然后pipework会根据这个container id获得这个container的pid。假设这个pid是<code>14806</code>，则<code>/proc/14806/ns/net</code>就是这个container真正的network namespace文件对象。pipework会在/var/run/netns/下创建一个指向这个文件的软链接。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><div class="line">ln -s <span class="meta-keyword">/proc/</span><span class="number">14806</span><span class="meta-keyword">/ns/</span>net <span class="meta-keyword">/var/</span>run<span class="meta-keyword">/netns/</span><span class="number">14806</span></div></pre></td></tr></table></figure>
<p>此时我们运行<code>ip netns list</code>时，就可以看到<code>14806</code>这个namespace。之后pipework会创建一个veth pair。大概是这样：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><div class="line">ip link add <span class="keyword">name</span> veth1pl14806 mtu <span class="number">1500</span> <span class="keyword">type</span> veth peer <span class="keyword">name</span> veth1pg14806 mtu <span class="number">1500</span></div></pre></td></tr></table></figure>
<p>其中mtu的具体值，实际中是直接使用<code>br0</code>的mtu值。<code>veth1pl14806</code>就是’v’加上container中要创建的interface名字，加上’p’，加上’l’(应该是local的意思)，在再加上container的pid。<code>veth1pg14806</code>同理，’l’换成’g’(guest)。当然，这个命名不重要，只要唯一就可以了。</p>
<p>之后，pipework会把<code>veth1pl14806</code>加到<code>br0</code>中。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><div class="line">## <span class="meta">if</span> <span class="keyword">br0 </span>is linux <span class="keyword">bridge</span></div><div class="line"><span class="symbol">ip</span> link set veth1pl14806 master <span class="keyword">br0 </span><span class="title">||</span> <span class="keyword">brctl </span><span class="keyword">addif </span><span class="keyword">br0 </span>veth1pl14806</div><div class="line">## <span class="meta">if</span> <span class="keyword">br0 </span>is OVS <span class="keyword">bridge</span></div><div class="line"><span class="symbol">ovs</span>-vsctl <span class="keyword">add-port </span><span class="keyword">br0 </span>veth1pl14806</div><div class="line">## <span class="keyword">bring </span><span class="keyword">it </span>up</div><div class="line"><span class="symbol">ip</span> link set veth1pl14806 up</div></pre></td></tr></table></figure>
<p>把<code>veth1pg14806</code>加到<code>14806</code>这个namespace中。然后改名成eth1，再配置<code>10.10.10.9/24</code>这个地址和相应路由。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><div class="line"><span class="built_in">ip</span> link set veth1pg14806 netns <span class="number">14806</span></div><div class="line"><span class="built_in">ip</span> netns exec <span class="number">14806</span> <span class="built_in">ip</span> link set veth1pg14806 name eth1</div><div class="line"><span class="built_in">ip</span> netns exec <span class="number">14806</span> <span class="built_in">ip</span> <span class="keyword">add</span> <span class="keyword">add</span> <span class="number">10.10</span><span class="meta">.10</span><span class="meta">.9</span>/<span class="number">24</span> dev eth1</div><div class="line">...</div></pre></td></tr></table></figure>
<p>最后会删除之前创建的软链接<code>/var/run/netns/14806</code>，来防止用户通过<code>ip netns</code>来做更改。</p>
</div><div class="post-footer">Updated on 16/07/10</div></div><div class="post-nav"><div style="height: 0; width: 0; position: absolute; visibility: hidden">
  <!-- inject:svg --><svg xmlns="http://www.w3.org/2000/svg"><symbol id="ic_chevron_left_white_24px" viewBox="0 0 24 24">
    <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</symbol><symbol id="ic_chevron_right_white_24px" viewBox="0 0 24 24">
    <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</symbol></svg><!-- endinjected -->
</div><a href="/2015/yum-repo-howto/" class="nav prev"><svg class="icon left"><use xlink:href="#ic_chevron_left_white_24px"></use></svg>PREVIOUS</a><a href="/2015/vagrant-is-pretty-good/" class="nav next">NEXT<svg class="icon right"><use xlink:href="#ic_chevron_right_white_24px"></use></svg></a></div></section><footer><h3>Carlog</h3><div class="additional"><span>&copy;</span> 2016 <a href="http://hanhaishan.com">Haishan</a><br> Powered by <a href="https://hexo.io">Hexo</a>, theme using <a href="https://github.com/haishanh/hexo-theme-zxcvb">zxcvb</a>, hosted by <a href="https://github.com/haishanh/blog/tree/gh-pages">Github Pages</a></div></footer><script src="/js/script.js"></script></body></html>